---
title: "Hierarchical ordination"
output: html_document
date: "2023-02-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
```

# An Example of Hierarchical Ordination

This document describes fitting a hierarchical ordination to data, including code and the nasty details that are needed.

The data is included in the 'mvabund' 'R'-package, but was originally collected by [Gibb *et al*](https://link.springer.com/article/10.1007/s00442-014-3101-9). It is the observed abundances of 41 ant species at 30 sites in Australia, along with 7 environmental variables, and 5 traits. The ecological question is how do the environmental variables and traits affect the community composition, including whether they interact. THe methodological question is how does hierarchical ordination help.

The abundances, traits and environment are each stored in a different matrix. First we load the data and set some constants:

```{r data, cache=FALSE, message=FALSE}
library(nimble)
library(nimbleHMC)
library(mvabund)
data("antTraits")
Y <- antTraits$abund # abundance data of sites by species
X <- scale(antTraits$env) # environmental variables of sites by predictors
TR <- scale(model.matrix(~0+.,antTraits$traits)) # species traits

NSites <- nrow(Y) # number of sites
NSpecies <- ncol(Y) # number of species
NTraits <- ncol(TR) # number of traits
NEnv <- ncol(X) # number of environmental predictors

# Create data lists for Nimble
dat <- list(Y = Y, X = X, TR = TR)
consts <- list(NSites = NSites, NEnv = NEnv, NTraits = NTraits, NSpecies = NSpecies)

```


## The Model

The data are counts of each species so we assume they follow a Poisson distribution with a log link function, as we would do in a standard genralised linear model. We assume each species has the same mean abundance (i.e. a different $\beta_{0j}$ for each species $j$), and model the rest of the variation with the hierarchical ordination. This gives the following model for the log of the mean abundance ($\eta_{ij}$):

$$
\eta_{ij} = \beta_{0j} + \boldsymbol{z}_i^\top \boldsymbol{\Sigma} \boldsymbol{\gamma}_j.
$$

As with a normal ordination, $\boldsymbol{z}$ and $\boldsymbol{\gamma}_j$ are the site scores and species loadings. But here we assume that they each have a variance of 1, so that $\boldsymbol{\Sigma}$ is the variance of the latent variables: it will typically be a diagonal matrix, and if any of the terms on the diagonal are close to 0, this suggests that latent variable has (almost) no effect. It thus provides a straightforward summary of the importance of that latent variable.

If we stopped here, this would be a standard GLLVM. But we want to model both $\boldsymbol{z}$ and $\boldsymbol{\gamma}_j$, i.e. go from modelling model groups of species responding in similar ways to sites to modelling how the traits of the species affect their responses to the environment.

As a simplification, we can think about this as simply a regression of $\boldsymbol{z}$ (the site effects) against the environmental variables and $\boldsymbol{\gamma}_j$ against the traits. In reality, it is more complicated, because $\boldsymbol{z}$ and $\boldsymbol{\gamma}_j$ are estimated in the model, so their uncertainty needs to be included.

<details><summary>The mathematical details are hidden away here, for those who want them.</summary>
We denote the abundance at site $i = 1 \dots n$ for species $j = 1 \dots p$ as $Y_{ij}$, or as a matrix as $\boldsymbol{Y}$. The environmental predictors are $X_{ik}$ for the $k = 1 \ldots K$ predictors (or $\boldsymbol{X}$ as a matrix), and $t = 1\ldots T$ traits as $\boldsymbol{R}$. We then assume

$$Y_{ij} \sim Pois(\lambda_{ij}),$$

with

$$log(\lambda_{ij}) = \eta_{ij}.$$

So that $\eta_{ij}$ is the linear predictor, which we will model with the hierarchical ordination:

$$
\eta_{ij} = \beta_{0j} + \boldsymbol{z}_i^\top \boldsymbol{\Sigma} \boldsymbol{\gamma}_j
$$

We then model $\boldsymbol{z}_i$ (as in [van der Veen *et al* (2023)](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.14035)) and $\boldsymbol{\gamma}_j$ hierarchically:

$$
\boldsymbol{z}_i = \boldsymbol{B}^\top\boldsymbol{x}_i + \boldsymbol{\epsilon}_i
$$
and 

$$
\boldsymbol{\gamma}_j = \boldsymbol{\omega}^\top\boldsymbol{R}_{j} + \boldsymbol{\varepsilon}_j
$$
where

- $x_{ik}$ is the $k^{th}$ predictor (i.e. environmental effect) at site $i$ 
- $\boldsymbol{B}$ with entry $b_{kq} \sim \mathcal{N}(0,1)$ is the effect of the $k^{th}$ predictor on the site score for the $q^{th} = 1\ldots d$ latent variable
- $\boldsymbol{\epsilon}_i$ with entry $\epsilon_{iq} \sim \mathcal{N}(0, \sigma^2_q)$ is a vector of residuals for the unexplained part of the site score
- $R_{jt}$ is the $t^{th}$ predictor (i.e. trait) for species $j$
- $\boldsymbol{\omega}_t$ with entry $\omega_{tq}$ is the effect of the $t^{th}$ trait on the species loading for the $q^{th}$ latent variable
- $\boldsymbol{\varepsilon}_j$ with entry $\varepsilon_{jq}  \sim \mathcal{N}(0, \delta^2_q)$ is a vector of residuals for the unexplained part of the species loading

Note that the predictors are all standardized to zero mean, variance one. We additionally place exponential priors on the scale parameters $\boldsymbol{\sigma}$ and $\boldsymbol{\delta}$ with rate parameter one.
</details>


# Implementation 

We fit the model with the $\texttt{Nimble}$ \texttt{R} package. We start with a single dimension for simplicity, so that we can show the steps needed.

### One dimensional ordination

The fitting process needs the mode, and the code to run it. 

<details><summary>The Nimble code that describes the model is here</summary>

```{r model_code, message=FALSE, warning=FALSE}
OneLV.nim <- nimbleCode({
  for (i in 1:NSites) {
    for (j in 1:NSpecies) {
# These three lines specify the model:   
      Y[i, j] ~ dpois(lambda[i, j]) # Likelihood: Y follows a Poisson distribution
      log(lambda[i, j]) <- eta[i, j] # Specify the log link function
      eta[i,j] <- beta0[j] + gammas[j]*LVsd*zs[i] # linear predictor: species + LV
    }
# Site scores: regression against environmental effects
#    the Bs are the coefficients of the environmental effects
      epsilon[i] ~ dnorm(0, sd = Sitesd) # Residual site effect
      XB[i] <- inprod(X[i, 1:NEnv],B[1:NEnv])
      z[i] <- XB[i] + epsilon[i]
  }
  
  for(j in 1:NSpecies) {
# Species effects: regression against trait effects
#    The Os are the trait effects.
      omegaTR[j] <- inprod(TR[j, 1:NTraits],O[1:NTraits])
      varepsilon[j] ~ dnorm(0, sd = Speciesd) # Residual
      gamma[j] <- omegaTR[j] + varepsilon[j]
      beta0[j] ~ dnorm(0, sd = 1) # S
  }
  
# Here we standardise z and gamma, so the both have a variance of 1.
#   The standard deviation of the latent variable is LVsd.
    zmu <- mean(z[1:NSites])
    zs[1:NSites] <- (z[1:NSites]-zmu)/sqrt(mean((z[1:NSites] - zmu)^2)) #scale z to unit sd and center
    gammamu<- mean(gamma[1:NSpecies])
    gammas[1:NSpecies] <- (gamma[1:NSpecies]-gammamu)/sqrt(mean((gamma[1:NSpecies] - gammamu)^2)) #scale gamma to unit sd and center
    # priors for scales
    Sitesd ~ dexp(1)
    Speciesd ~ dexp(1)
    LVsd ~ dexp(1)

    for(k in 1:NEnv){
      B[k] ~ dnorm(0, sd = 1)  
    }
    for(tr in 1:NTraits){
      O[tr] ~ dnorm(0, sd = 1)
    }
})
```
</details>

<details><summary>The MCMC needs initial values to start from: the function to generate these is here 
</summary>

```{r init}

inits<-function(consts){
  B = rnorm(consts$NEnv)
  O = rnorm(consts$NTraits)
  varepsilon = rnorm(consts$NSpecies)
  epsilon = rnorm(consts$NSites)
  list(
    B = B,
    O = O,
    epsilon = epsilon,
    varepsilon = varepsilon,
    Sitesd = rexp(1),
    Speciesd = rexp(1),
    beta0 = rnorm(consts$NSpecies),
    LVsd = rexp(1)
  )
}
```

</details>

We parallelise running the MCMC so that each chain is run on a different processor. This means we need a function to run one chain, and then another to run all of the chains together.


<details><summary>Functions to run the code are here.</summary>

```{r mcmc_code}

# Function to run one chain: it can be done with HMC or other MCMC algorithms.
RunOneChain <- function(seed, dat, code, inits, consts, 
                        Nburn=5e3, NIter=5.5e4, Nthin=10, HMC = FALSE, ...) {
  require(nimble)
  require(nimbleHMC)
  AllSamplers <-c('epsilon', 'varepsilon', 'beta0', 'O', 'B',
                  'Sitesd', 'Speciesd', 'LVsd')
  HMCsamplers <-c('epsilon', 'varepsilon','B', 'O', 'beta0', 'Sitesd', 'Speciesd', 'LVsd')
  
  Mons <- c("beta0","Speciesd","Sitesd","LVsd","B","O", "epsilon","varepsilon")
  mod <- nimbleModel(code = code, name = "HO", constants = consts, 
                     inits = inits(consts), data = dat, buildDerivs = TRUE)
  model <- compileNimble(mod)
  if(HMC) { # Do HMC on everything
    conf <- configureHMC(model, monitors = Mons, print = FALSE, control=list(nwarmup=Nburn, kappa=0.95))
    # Use a slice everything that not being HMCed
    Slicesamplers <-AllSamplers[!AllSamplers%in%HMCsamplers] 
    conf$removeSamplers(Slicesamplers)
    sapply(Slicesamplers, conf$addSampler, type = "AF_slice")
  } else {
    conf <- configureMCMC(model, monitors = Mons, print = FALSE)
    # Change the samplers to block update, using a nifty extension of the slice sampler
    Slicesamplers <-c('epsilon', 'varepsilon')
    conf$removeSamplers(Slicesamplers)
    conf$addSampler(target = Slicesamplers, type = "AF_slice")
  }
  mcmc <- buildMCMC(conf)
  cmcmc <- compileNimble(mcmc, project = model)
  res <- runMCMC(cmcmc,  niter=NIter, nburnin = Nburn, thin=Nthin, 
                 nchains = 1, samplesAsCodaMCMC = TRUE, ...)
  return(res)
}

# Function to run parallel chains
ParaNimble <- function(NChains, ...) {
  require(parallel)
  nimble_cluster <- makeCluster(4)
  
  samples <- parLapply(cl = nimble_cluster, X = 1:4,...)
  stopCluster(nimble_cluster)

  # Name the chains in the list
  chains <- setNames(samples,paste0("chain", 1:length(samples)))
  chains
}

```

</details>

These models are notorious for being unidentifiable, i.e. you can get the same mean abundances from different combinations of the parameters. We therefore have to make some adjustments to the model: some of this is done in the model fitting, but for others it is easier to do it afterwards.

<details><summary>The details of what we do to make this identifiable are here</summary>

- First, we standardise $\boldsymbol{z}_i$ and $\boldsymbol{\gamma}_j$ to unit variance per latent variable to prevent scale invariance. 
- At this point the model is still invariant to sign switching: because $z_{i}\gamma_{j} = (-z_{i})(-\gamma_{j})$ the MCMC algorithm can (and does) swith signs during the MCMC run. We could solve it by placing a truncated normal prior on the main diagonal entries of $\boldsymbol{B}$ or $\boldsymbol{\omega}$, but that still results in a bimodal posterior distribution for other coefficients. Instead we leave this as it is during the MCMC and post-process the chains. We chose one variable, i.e. one $z_{i}$ or $\gamma_{j}$, to fix to be positive, and switch all of the other variables. If we choose a variable that should only be of one sign, this will fix the problem. see below for the details of how we do this here.
- Note however, that for $d \gt p$ the model is still invariant to sign switches, so if the number of latent variables is greater than the number of predictors, additional constraints need to be imposed on the diagonal of $\boldsymbol{\omega}$ or on the $\boldsymbol{\epsilon}_i$'s or $\boldsymbol{\epsilon}_j$'s instead. Obviously we do not need to do this in this model, but is included below for the more general case.

The functions to swap signs are below. We want to make one parameter positive, so ideally we want to do this to a parameter that doesn't want to swap signs. We identify this in an **ad hoc** way: for each chain for every parameter we calculate the proportion of iterations where the sign is positive, and then for every parameter we calculate the variance in the proportion. If a parameter is centred around 0, then the mean proportion will be about 0.5, and will not vary much, whereas if it is some way from 0 the mean will be close to 0 or 1, and the variance will be high.

An alternative approach would be to look at the largest $|p - 0.5|$. There may be better alternatives too.

```{r ProcessFunction, eval=TRUE}

# Utility Function to get logical indicators for if names contains a string in v
GetInds <- function(v, names) {
  if(length(v)==1) {
    res <- grep(v, names)
  } else {
    res <- c(unlist(sapply(v, grep, x=names)))
  }
  res
}

# Function to swap signs of all variables varinds to have same sign as vartosign.
#    Might have to change this to make sure different chains stick to the same sign
ReSignChain <- function(chain, varinds, vartosign) {
  #    MeanSign <- sign(mean(chain[  ,s])) # Might need this
  res <- t(apply(chain, 1, function(x, vartosign, varinds) {
    Names <- names(x)[varinds]
    if(any(grepl(",", Names))) {
      lvind <- gsub(".*, ", "", Names)
    } else {
      lvind <- seq_along(vartosign)
    }
    x[varinds] <- x[varinds]*sign(x[vartosign[lvind]])
    x
  }, vartosign=vartosign, varinds=varinds))
  as.mcmc(res)
}

# Function to post-process chains to be identifiable.
postProcess <- function(Chains, VarsToProcess, VarToSign=NULL) {
  if(is.null(VarToSign)) VarToSign <- VarsToProcess
  ind <- GetInds(VarToSign, colnames(Chains[[1]]))
  # Get indicators for all variables to have their signs changed
  ProcessInds <- GetInds(VarsToProcess, names = colnames(Chains[[1]]))
  
  # Check if > 1 LV
  SeveralLVs <- any(grepl(",", colnames(Chains[[1]])[ind]))
  
  # Calculate variance of mean of indicator of sign: 
  #    hopefully largest is variable with most sign swapping (i.e. )
  Signs <- as.data.frame(lapply(Chains, function(mat, ind) 
    colMeans(mat[,ind]>0), ind=ProcessInds))
    VarSign <- apply(Signs, 1, var)
  
  if(SeveralLVs) {
    LV <- gsub(".*, ", "", colnames(Chains[[1]])[ind])
    #Chose variables who's sign will be used to swap other signs
    VarsToSwapBy <- sapply(unique(LV), function(lv, vs) {
      vv <- vs[grep(lv, names(vs))]
      nm <- names(which(vv==max(vv)))
      if(length(nm)>1) nm <- nm[1] # probably something more sophisticated is better
      nm
    }, vs = VarSign, simplify = TRUE)
    chains.sgn <- lapply(Chains, ReSignChain, vartosign=VarsToSwapBy, varinds=ProcessInds)
    
  } else { # only 1 LV
    #Chose variables who's sign will be used to swap other signs
    VarsToSwapBy <- names(which(VarSign==max(VarSign)))[1]
#    chains.sgn <- lapply(Chains, ReSignChain, varNames=VarsToProcess, sign.var=ind)
    chains.sgn <- lapply(Chains, ReSignChain, vartosign=VarsToSwapBy, varinds=ProcessInds)
  }
  as.mcmc.list(chains.sgn)
}

```

</details>

Finally, we can run the MCMC.

```{r MCMCrun, message=FALSE}
chains.unsgn <- ParaNimble(4, fun = RunOneChain,
                       dat = dat,
                       code = OneLV.nim,
                       inits = inits, HMC = TRUE,
#                       Nburn=5e1, NIter=5.5e2, Nthin=1, # for a small run
                       Nburn=1e3, NIter=2e3, Nthin=1, # for a big HMC run
                       consts = consts)

# post-process chains for sign-swapping
VarsToProcess <- c("^B", "^O", "^epsilon", "^varepsilon")
chains <- postProcess(chains.unsgn, VarsToProcess=VarsToProcess)
summ.HO = summary(chains)

```

### Results

There are a lot  of parameters, so a lot of results to look at. Here we concentrate on $\boldsymbol{B}$, $\boldsymbol{\omega}$, $\boldsymbol{\sigma}$ and $\boldsymbol{\delta}$, and a latent variable-plot.

<details>
    <summary>We can look at the chains, to see that they have converged.</summary>

First the environmental effects

```{r results1, warning=FALSE, message=FALSE}

library(basicMCMCplots)
chainsPlot(chains, var = c("B"), legend = F,traceplot=T)

```

Then the trait effects

```{r ResO, warning=FALSE,message=FALSE, fig.height=10}
chainsPlot(chains, var = c("O"), legend = F,traceplot=TRUE)

```

</details>


These look quite OK (after post-processing). Now we can create a plot of the LV-scores against their indices to inspect the results.

<details><summary>We use a plotting function, which is hidden here</summary>

```{r plotEnv1LVfunction, warning=FALSE,message=FALSE, fig.height=4}
PlotPost <- function(var, summ, varnames=NULL, ...) {
  vars <- grep(var, rownames(summ$statistics))
  if(is.null(varnames)) varnames <- rownames(summ$statistics)
  if(length(varnames)!=length(vars)) 
    stop(paste0("Number of variable names, ", length(varnames), "not the same as number of variables, ",
                length(vars)))
  
  plot(summ$statistics[vars,"Mean"], 1:length(vars), 
       xlim=range(summ$quantiles[vars,]), yaxt="n", ...)
  segments(summ$quantiles[vars,"2.5%"], 1:length(vars), summ$quantiles[vars,"97.5%"], 1:length(vars))
  segments(summ$quantiles[vars,"25%"], 1:length(vars), summ$quantiles[vars,"75%"], 1:length(vars), lwd=3)
  abline(v=0, lty=3)
  axis(2, at=1:length(vars), labels=varnames, las=1)
}
```
</details>

```{r plotEnv1LV, warning=FALSE,message=FALSE, fig.height=4}
par(mar=c(4.1,4.5,1,1))
PlotPost(var="B", summ=summ.HO, varnames = gsub("\\.", "\n", colnames(X)), 
         xlab="Environmental Effect", ylab="")

```


We can see that both Coarse woody debris and canopy cover have positive effects on the latent variable, so ants that have a positive species score will be more abundant in areas with more canopy cover and CWD. 

These species also tend to be hairy (i.e. not have a pilosity of 0):

```{r plotTraits1LV, warning=FALSE,message=FALSE, fig.height=6}
par(mar=c(4.1, 7,1,1))
PlotPost(var="O", summ=summ.HO, varnames = gsub("\\.", "\n", colnames(TR)), 
         xlab="Trait Effect", ylab="")

```

We can also calculate the full distributions of site and species scores.

<details><summary>We use a function, which is hidden here</summary>

```{r CalcScoresFunctions, warning=FALSE,message=FALSE}

ExtractScore <- function(mcmc.lst, betaname, epsname, XX, summ=FALSE) {
  betaind <- grep(paste0('^', betaname), colnames(mcmc.lst[[1]]))
  epsind <- grep(paste0('^', epsname), colnames(mcmc.lst[[1]]))

  PostScore2 <- function(mc, LV=0, ...) {
    if(ncol(XX)==length(betaind)) {
      as.mcmc(t(apply(mc, 1, CalcScore, ...)))
    } else {
 
    LV.beta <- gsub(".*, |]", "", colnames(mc)[betaind])
    LV.eps <- gsub(".*, |]", "", colnames(mc)[epsind])
    LVs <- unique(LV.beta)
    
    res <-  sapply(LVs, function(lv, mc, betaind, epsind, l.be, l.e, XX) {
      bInd <- betaind[l.be==lv]
      eInd <- epsind[l.e==lv]

      apply(mc, 1, CalcScore, betaind=bInd, epsind=eInd, XX=XX)
    },  mc = mcmc.lst[[1]], betaind=betaind, epsind=epsind, l.be=LV.beta, l.e=LV.eps, XX=XX, simplify=FALSE)
    
    res.mcmc <- as.mcmc(t(do.call(rbind, res)))
    res.mcmc
    }
  }

  CalcScore <- function(v, betaind, epsind, XX) {
    res <- XX%*%v[betaind] + v[epsind]
    names(res) <- names(v[epsind])
    res
  }

  score <- as.mcmc.list(lapply(mcmc.lst, PostScore2, betaind=betaind, epsind=epsind, XX=XX))
  if(summ) score <- summary(score)
  score
}


```

<details>
  
```{r PlotScores, fig.height=14}
LVs <- ExtractScore(mcmc.lst=chains, betaname="B", epsname="epsilon", XX=X, summ=TRUE)
gamma <- ExtractScore(mcmc.lst=chains, betaname="O", epsname="varepsilon", XX=TR, summ=TRUE)

par(mfrow=c(2,1), mar=c(2,12,4,1))
PlotPost("^", summ=LVs, varnames = NULL, ylab="", xlab="Latent variable 1", main = "Sites")
PlotPost("^", summ=gamma, varnames = NULL, ylab="", xlab="Latent variable 1", main = "Species")

```


## More dimensions

More than one dimension requires adding extra identifiability constraints. Now we have two or more latent variables, we also have to worry about rotating them.

<details><summary>For those who are interested, this is how we deal with the rotations</summary>
There are various ways to place the constraints, some more numerically stable than others. Generally, we note that the model on the link scale is similar to existing matrix decompositions, so that much on the required constraints can be learned from those.
 
To prevent rotational invariance, we require $\boldsymbol{B}$ and $\boldsymbol{\omega}$ to have zeros above the main diagonal. van der Veen *et al* (2023) instead assumed $\boldsymbol{B}$ to be a semi-orthogonal matrix as they encountered numerical instability with the constraint that we impose here. However, their constraint would require sampling on constrained parameter spaces, which is difficult, while this constraint formulation allows to use standard out-of-the-box Markov Chain Monte carlo samplers (also, it seems to work fine here). Note, that when $d \gt p,t $ the model is again rotationally invariant, and additional constraints (e.g., order constraints for the latent variables as in a varimax rotation) will need to be added.
</details>

<details><summary>The new model code is almost the same as before</summary>

```{r model2_code, message=FALSE, warning=FALSE}
# Update our constants from before with the new number of LVs, rest remains the same
consts$nLVs <- nLVs <- 2
# Model code
HO.nim <- nimbleCode({
  for (i in 1:NSites) {
    for (j in 1:NSpecies) {
      eta[i,j] <- beta0[j] + sum(gammas[j,1:nLVs]*LVsd[1:nLVs]*zs[i,1:nLVs])
      log(lambda[i, j]) <- eta[i, j]
      Y[i, j] ~ dpois(lambda[i, j])
    }      
    for (q in 1:nLVs) {
      XB[i, q] <- sum(X[i, 1:NEnv]*B[1:NEnv, q])
      epsilon[i,q] ~ dnorm(0,Sitesd[q])#Residual
      z[i,q] <- XB[i,q] + epsilon[i,q]
    }
  }
  
  for(j in 1:NSpecies) {
    for (q in 1:nLVs) {
      omegaTR[j, q] <- sum(TR[j, 1:NTraits]*O[1:NTraits, q])
      varepsilon[j,q] ~ dnorm(0,Speciesd[q]) # Residual
      gamma[j,q] <- omegaTR[j,q] + varepsilon[j,q]
    }
    
    beta0[j] ~ dnorm(0, sd=1)
  }
  # Constraints to 0 on upper diagonal
  # stole some code from Boral for this - thanks Francis
  for(i in 1:(nLVs-1)) { 
    for(j in (i+1):(nLVs)) {
      B[i,j] <- 0 
    } 
  }
  
  for(i in 1:nLVs) { 
    # diagonal elements
    B[i,i] ~ dnorm(0,sd=10)
    ## standardizing z and gamma
    zmu[i] <- mean(z[1:NSites,i])
    zs[1:NSites,i] <- (z[1:NSites,i]-zmu[i])/sqrt(mean((z[1:NSites,i] - zmu[i])^2)) #scale z to unit sd and center
    gammamu[i] <- mean(gamma[1:NSpecies,i])
    gammas[1:NSpecies,i] <- (gamma[1:NSpecies,i]-gammamu[i])/sqrt(mean((gamma[1:NSpecies,i] - gammamu[i])^2)) #scale gamma to unit sd and center
    # priors for scales
    Sitesd[i] ~ dexp(1)
    Speciesd[i] ~ dexp(1)
    LVsd[i] ~ dexp(1)
    } 
  
  ## Free lower diagonals
  for(i in 2:nLVs) { 
    for(j in 1:(i-1)) { 
      B[i,j] ~ dnorm(0,sd=10)
      } 
    }
  for(i in (nLVs+1):NEnv) { for(j in 1:(nLVs)) { B[i,j] ~dnorm(0,1) } } ## All other elements

  # Prior for trait effects
    for(tr in 1:NTraits){
    for(q in 1:nLVs){
      O[tr,q] ~dnorm(0,1)
    }
  }
})
```

</details>

<details><summary>We create a new function to simulate starting values from the prior distributions, which we can hide away</summary>

```{r init2}
inits<-function(consts){
  B = matrix(rnorm(consts$nLVs*consts$NEnv),ncol=consts$nLVs)
  B[upper.tri(B)] = 0
  O = matrix(rnorm(consts$nLVs*consts$NTraits),nrow=consts$NTraits)
  varepsilon = mvtnorm::rmvnorm(consts$NSpecies,rep(0,consts$nLVs),diag(consts$nLVs))
  epsilon = mvtnorm::rmvnorm(consts$NSites,rep(0,consts$nLVs),diag(consts$nLVs))
  list(
    B = B,
    O = O,
    epsilon = epsilon,
    varepsilon = varepsilon,
    Sitesd = rexp(consts$nLVs),
    Speciesd = rexp(consts$nLVs),
    beta0 = rnorm(consts$NSpecies),
    LVsd = rexp(consts$nLVs)
  )
}
```
</details>

We can run the fitting with the same code as before:

```{r mcmc2_run}
HO.2LV <- ParaNimble(4, fun = RunOneChain,
                       dat = dat,
                       code = HO.nim,
                       inits = inits, HMC=TRUE,
#                       Nburn=5e1, NIter=5.5e2, Nthin=1, # for a small run
                       Nburn=1e3, NIter=3e3, Nthin=1, # for a full run
                       consts = consts)

# post-process chains for sign-swapping
chains2LV <- postProcess(HO.2LV, VarsToProcess=VarsToProcess, VarToSign = VarsToProcess)
summ.HO2LV = summary(chains2LV)

```


## Results

<details><summary>Again, check they work.</summary>
Environment first:

```{r results2, fig.height=10}

chainsPlot(chains2LV, var = c("B"), legend = F, traceplot=TRUE)

```

And the trait effects:

```{r ResO2LV, warning=FALSE,message=FALSE, fig.height=25}
chainsPlot(chains2LV, var = c("O"), legend = F, traceplot=TRUE)
#chainsPlot(chains2LV, var = c("epsilon"), legend = F, traceplot=FALSE)

```

</details>

The traceplots look OK, although B[2,1] looks bimodal. There appears to be  Now, we can make two-dimensional ordination plots of sites and species, with their predictor effects.

<details><summary>We need a function to plot the arrows, which is hidden here</summary>
```{r AddArrows}
AddArrows <- function(coords, marg= par("usr"), col=2) {
  origin <- c(mean(marg[1:2]), mean(marg[3:4]))
  Xlength <- sum(abs(marg[1:2]))/2
  Ylength <- sum(abs(marg[3:4]))/2
  ends <- coords / max(abs(coords)) * min(Xlength, Ylength) * .8
  arrows(
    x0 = origin[1],
    y0 = origin[2],
    x1 = ends[,
              1] + origin[1],
    y1 = ends[, 2] + origin[2],
    col = col,
    length = 0.1)
  text(
    x = origin[1] + ends[, 1] * 1.1,
    y = origin[2] + ends[, 2] * 1.1,
    labels = rownames(coords),
    col = col)
  
}

```
</details>

```{r results2_site, warning=FALSE}
ExtractMeans <- function(summ, name, d=1) {
  if(is.null(d)) d <- 1
  var <- summ$statistics[grep(paste0('^', name), rownames(summ$statistics)),"Mean"]
  matrix(var,ncol=d)
}




# First a plot of the site scores
eps.m <- ExtractMeans(summ.HO2LV, name="epsilon", d=consts$nLVs)
B.m <- ExtractMeans(summ.HO2LV, name="B", d=consts$nLVs)
rownames(B.m) <- colnames(X)
LVs <- X%*%B.m+eps.m

# Now the species loadings
vareps.m <- ExtractMeans(summ.HO2LV, name="varepsilon", d=consts$nLVs)
O.m <- ExtractMeans(summ.HO2LV, name="O", d=consts$nLVs)
rownames(O.m) <- colnames(TR)
gamma <- TR%*%O.m+vareps.m

LVs <- ExtractScore(mcmc.lst=chains2LV, betaname="B", epsname="epsilon", XX=X, summ=TRUE)
gamma <- ExtractScore(mcmc.lst=chains2LV, betaname="O", epsname="varepsilon", XX=TR, summ=TRUE)



par(mfrow=c(1,2))

#LVs
plot(LVs,type="n", xlab="Latent variable 1", ylab="Latent variable 2", main = "Sites")
text(LVs,labels=1:consts$NSites)
AddArrows(marg = par("usr"), coords=B.m, col="red")

#gammas
plot(gamma,type="n", xlab="Latent variable 1", ylab="Latent variable 2", main = "Species")
text(gamma,labels=vegan::make.cepnames(colnames(Y)))
AddArrows(marg = par("usr"), coords=O.m, col="blue")


```

We can also look at some summary statistics for the scale parameters of the latent variables, species-specific residuals and site-specific residuals, respectively:

```{r sum_stats}

SDs <- summ.HO2LV$statistics[grep("sd", rownames(summ.HO2LV$statistics)),c("Mean", "SD")]
knitr::kable(SDs, digits=2, format = "html", table.attr = "style='width:30%;'")

```

These tell us how well the predictors explain the ordination; the species- and site-specific scale parameters would be zero if the predictors fully explained the ordination. The scale parameters for the latent variables are similar to singular values (the square root of eigenvalues) in a classical ordination; they reflect a dimension its importance to the response.

## Residual covariance matrix

The covariance of species is determined by traits, LV-specific variation and sites' residual variation, and the covariance between sites is determined by the environment, LV-specific variation and species' residual variation.

<details><summary>The maths behind this is covered in here</summary>
The residual covariance matrix of the model (where you calculate species associations from) is determined by three terms:

1) $\boldsymbol{X}\boldsymbol{B}\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_j \sim \mathcal{N}(0,\boldsymbol{X}\boldsymbol{B}\boldsymbol{\Sigma}\text{diag}(\boldsymbol{\delta}^2)\boldsymbol{\Sigma}\boldsymbol{B}^\top\boldsymbol{X}^\top)$
2) $\boldsymbol{TR}\boldsymbol{\omega}\boldsymbol{\Sigma}\boldsymbol{\epsilon}_i\sim \mathcal{N}(0,\boldsymbol{T}\boldsymbol{\omega}\boldsymbol{\Sigma}\text{diag}(\boldsymbol{\sigma}^2)\boldsymbol{\Sigma}\boldsymbol{\omega}^\top\boldsymbol{T}^\top)$
3) $\boldsymbol{\epsilon}_i^\top\boldsymbol{\varepsilon}_j \sum \limits^{d}_{q=1}\Sigma_{q,q}\sigma_q\delta_q\sim \mathcal{K}_0(\sigma^{-1}_q\delta^{-1}_q\vert\epsilon_{iq}\varepsilon_{iq}\vert)$,

where $\mathcal{K}_0$ denotes the zero order modified Bessel function of the second kind. The first term tells us that correlations between species are determined by the environment. The second term tells us that the correlation between sites is determined by species traits. The last term induces no correlation between sites and species for diagonal $\boldsymbol{\Sigma}$, but serves to scale species associations. Consequently, the covariance for species $j,j2$ and site $i,i2$ is:
\begin{multline}
\Sigma_{i,i2,j,j2} =
\text{cov}(\boldsymbol{x}_i^\top\boldsymbol{B}\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_j,\boldsymbol{x}_{i2}^\top\boldsymbol{B}\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_{j2}) +
\text{cov}(\boldsymbol{x}_i^\top\boldsymbol{B}\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_j,\boldsymbol{tr}_{j2}^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\boldsymbol{\epsilon}_{i2}) +
\text{cov}(\boldsymbol{x}_i^\top\boldsymbol{B}\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_j,\boldsymbol{\epsilon}_{i2}^\top\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_{j2}) + 
\text{cov}(\boldsymbol{tr}_j^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\boldsymbol{\epsilon}_i,\boldsymbol{x}_{i2}^\top\boldsymbol{B}\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_{j2}) +
\text{cov}(\boldsymbol{tr}_{j}^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\boldsymbol{\epsilon}_{i},\boldsymbol{tr}_{j2}^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\boldsymbol{\epsilon}_{i2}) + \\
\text{cov}(\boldsymbol{tr}_j^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\boldsymbol{\epsilon}_i,\boldsymbol{\epsilon}_{i2}^\top \boldsymbol{\Sigma}\boldsymbol{\varepsilon}_{j2}) +
\text{cov}(\boldsymbol{\epsilon}_{i}^\top \boldsymbol{\Sigma}\boldsymbol{\varepsilon}_{j},\boldsymbol{x}_{i2}^\top\boldsymbol{B}\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_{j2}) +
\text{cov}(\boldsymbol{\epsilon}_{i}^\top \boldsymbol{\Sigma} \boldsymbol{\varepsilon}_{j},\boldsymbol{tr}_{j2}^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\boldsymbol{\epsilon}_{i2})+
\text{cov}(\boldsymbol{\epsilon}_i^\top \boldsymbol{\Sigma}\boldsymbol{\varepsilon}_j,\boldsymbol{\epsilon}_{i2}^\top \boldsymbol{\Sigma}\boldsymbol{\varepsilon}_{j2}),
\end{multline}
third order terms are zero for central normal random variables, so this simplifies to:
\begin{equation}
\Sigma_{i,i2,j,j2} =
\boldsymbol{x}_i^\top\boldsymbol{B}\boldsymbol{\Sigma}\text{cov}(\boldsymbol{\varepsilon}_j,\boldsymbol{\varepsilon}_{j2}) \boldsymbol{\Sigma}\boldsymbol{B}^\top\boldsymbol{x}_{i2}+
\boldsymbol{x}_i^\top\boldsymbol{B}\boldsymbol{\Sigma}\text{cov}(\boldsymbol{\varepsilon}_j,\boldsymbol{\epsilon}_{i2})\boldsymbol{\Sigma}\boldsymbol{\omega}^\top\boldsymbol{tr}_{j2} +
\boldsymbol{tr}_j^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\text{cov}(\boldsymbol{\epsilon}_i,\boldsymbol{\varepsilon}_{j2})\boldsymbol{\Sigma}\boldsymbol{B}^\top\boldsymbol{x}_{i2} +
\boldsymbol{tr}_{j}^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\text{cov}(\boldsymbol{\epsilon}_{i},\boldsymbol{\epsilon}_{i2})\boldsymbol{\Sigma}\boldsymbol{\omega}^\top\boldsymbol{tr}_{j2} +
\text{cov}(\boldsymbol{\epsilon}_i^\top \boldsymbol{\Sigma}\boldsymbol{\varepsilon}_j,\boldsymbol{\epsilon}_{i2}^\top \boldsymbol{\Sigma} \boldsymbol{\varepsilon}_{j2}).
\end{equation}
Here, $\text{cov}(\boldsymbol{\varepsilon}_j,\boldsymbol{\epsilon}_{i2}) = \text{cov}(\boldsymbol{\epsilon}_i,\boldsymbol{\varepsilon}_{j2}) = 0$, and for  $\text{cov}(\boldsymbol{\epsilon}_i^\top\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_j,\boldsymbol{\epsilon}_{i2}^\top\boldsymbol{\Sigma}\boldsymbol{\varepsilon}_{j2}) = 2\text{tr}(\text{diag}(\boldsymbol{\delta}^2)\boldsymbol{\Sigma}\text{diag}(\boldsymbol{\sigma}^2)\boldsymbol{\Sigma})$. Further, $\text{cov}(\boldsymbol{\varepsilon}_j,\boldsymbol{\varepsilon}_{j2})$ is zero for $j \neq j2$ and $\text{diag}(\boldsymbol{\delta}^2)$ otherwise, and similar for $\text{cov}(\boldsymbol{\epsilon}_i,\boldsymbol{\epsilon}_{i2})$ .

Consequently, for a species association matrix where we consider the block of the covariance matrix where $i = i2$, or for the site-to-site matrix where we consider the block $j  = j2$, we have:

\begin{split}
\Sigma_{j,j2} &=
\boldsymbol{x}_i^\top\boldsymbol{B}\boldsymbol{\Sigma}\text{cov}(\boldsymbol{\varepsilon}_j,\boldsymbol{\varepsilon}_{j2}) \boldsymbol{\Sigma}\boldsymbol{B}^\top\boldsymbol{x}_{i} +
\text{cov}(\boldsymbol{\epsilon}_i^\top \boldsymbol{\Sigma}\boldsymbol{\varepsilon}_j,\boldsymbol{\epsilon}_{i}^\top \boldsymbol{\Sigma} \boldsymbol{\varepsilon}_{j2}) + 
\boldsymbol{tr}_{j}^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\text{var}(\boldsymbol{\epsilon}_{i},\boldsymbol{\epsilon}_{i})\boldsymbol{\Sigma}\boldsymbol{\omega}^\top\boldsymbol{tr}_{j2} \\
&= \boldsymbol{x}_i^\top\boldsymbol{B}\boldsymbol{\Sigma}\text{cov}(\boldsymbol{\varepsilon}_j,\boldsymbol{\varepsilon}_{j2}) \boldsymbol{\Sigma}\boldsymbol{B}^\top\boldsymbol{x}_{i} +
\boldsymbol{tr}_{j}^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\text{diag}(\boldsymbol{\sigma}^2)\boldsymbol{\Sigma}\boldsymbol{\omega}^\top\boldsymbol{tr}_{j2}+
2\text{tr}\{\text{diag}(\boldsymbol{\delta}^2)\boldsymbol{\Sigma}\text{diag}(\boldsymbol{\sigma}^2)\boldsymbol{\Sigma}\},
\end{split}

and 

\begin{equation}
\Sigma_{i,i2} = 
\boldsymbol{tr}_{j}^\top\boldsymbol{\omega}\boldsymbol{\Sigma}\text{cov}(\boldsymbol{\epsilon}_{i},\boldsymbol{\epsilon}_{i2})\boldsymbol{\Sigma}\boldsymbol{\omega}^\top\boldsymbol{tr}_{j} +
\boldsymbol{x}_i^\top\boldsymbol{B}\boldsymbol{\Sigma}\text{diag}(\boldsymbol{\delta}^2)\boldsymbol{\Sigma}\boldsymbol{B}^\top\boldsymbol{x}_{i2} + 
2\text{tr}\{\text{diag}(\boldsymbol{\delta}^2)\boldsymbol{\Sigma}\text{diag}(\boldsymbol{\sigma}^2)\boldsymbol{\Sigma}\}.
\end{equation}
</details>

 We can visualize those matrices here for (e.g.,) the first site and first species, respectively.

```{r residualcov}
#species
spec.mat <- matrix(0,nrow=NSpecies,ncol=NSpecies)
Sigma <- diag(SDs[grep("LV", rownames(SDs)),1]^2)
Sigma.sp <- diag(SDs[grep("Specie", rownames(SDs)),1]^2)
Sigma.si <- diag(SDs[grep("Site", rownames(SDs)),1]^2)

for(j in 1:NSpecies){
  for(j2 in 1:NSpecies){
    if(j==j2){
      spec.mat[j,j2] = X[1,,drop=F]%*%B.m%*%Sigma%*%Sigma.sp%*%t(B.m)%*%t(X[1,,drop=F])
    }
    spec.mat[j,j2] = spec.mat[j,j2] + TR[j,,drop=F]%*%O.m%*%Sigma%*%Sigma.si%*%Sigma%*%t(O.m)%*%t(TR[j2,,drop=F]) + 2*sum(diag((Sigma.sp%*%Sigma%*%Sigma.si%*%Sigma)))
  }
}

spec.cor.mat <- cov2cor(spec.mat)
colnames(spec.cor.mat) <- row.names(spec.cor.mat) <- colnames(Y)
corrplot::corrplot(spec.cor.mat,type = "lower",order = "AOE", main = "Species", mar = c(1,1,1,1),tl.srt=45,tl.cex = .5)

#sites
site.mat <- matrix(0,nrow=NSites,ncol=NSites)

for(i in 1:NSites){
  for(i2 in 1:NSites){
    if(i==i2){
      site.mat[i,i2] = TR[1,,drop=F]%*%O.m%*%Sigma%*%Sigma.si%*%t(O.m)%*%t(TR[1,,drop=F])
    }
    site.mat[i,i2] = site.mat[i,i2] + X[i,,drop=F]%*%B.m%*%Sigma%*%Sigma.sp%*%Sigma%*%t(B.m)%*%t(X[i2,,drop=F]) + 2*sum(diag((Sigma.sp%*%Sigma%*%Sigma.si%*%Sigma)))
  }
}

site.cor.mat <- cov2cor(site.mat)
colnames(site.cor.mat) <- row.names(site.cor.mat) <- paste("Site", 1:NSites)
corrplot::corrplot(site.cor.mat,type = "lower",order = "AOE", main = "Sites", mar = c(3,3,3,3),tl.srt=45,tl.cex = .5)
```
